# Лэмпела-Зива

## Кодирование с целью сжатия 
способ преобразования данных так, чтобы они занимали меньше места в памяти. Это достигается за счет устранения избыточности в данных.

**Виды сжатий:**

1. Без потерь - данные полностью восстанавливаются, после распоковки
2. С потерями - данные восстанавливаются не полностью, но это незначительные потери.

---
## Алгоритм Лэмпела - Зива 
это алгоритм сжатия без потерь, который работает путем поиска повторяющихся последовательностей в данных. Он заменяет повторения укзателями(ссылками) на их предыдущее местоположение.

###  **Алгоритм - пошагово**  

#### **Подготовка словаря**  
- В словарь сразу добавляется **пустая строка** (обозначим её `X`). Её индекс — `0`.  
- Это нужно для старта: любая новая буква сначала сочетается с этой пустой строкой.  

#### **Разбиваем текст на части**  
Исходный текст (например, `"АБАКАН..."`) обрабатывается по шагам:  

1. **Ищем в словаре** максимально длинную часть текста (`Y`), которая уже есть в словаре.  
2. **Берём следующий символ** после этой части (`A`) — это "расширяющая буква".  
3. **Формируем новую запись** для словаря: `YA` (известная часть `Y` + новая буква `A`).  
4. **Кодируем** эту запись парой чисел: `⟨индекс_Y, A⟩`.  
5. **Обновляем текст** — убираем из него обработанную часть `YA`.  

Повторяем, пока весь текст не закончится.  

---

### **Пример**  
Возьмём текст `"АБАКАН".  

#### **Шаг 1**  
- Словарь: `{0: X}`  
- Текст: `"АБАКАН"`  
- Находим `Y` (макс. часть из словаря) — это `X` (пустота).  
- След. символ `A`.  
- Добавляем в словарь: `1: A` (код `⟨0, A⟩`).  
- Новый текст: `"БАКАН"`.  

#### **Шаг 2**  
- Словарь: `{0: X, 1: A}`  
- Текст: `"БАКАН"`  
- Макс. часть `Y` — `X`, след. символ `Б`.  
- Добавляем `2: Б` (код `⟨0, Б⟩`).  
- Новый текст: `"АКАН"`.  

#### **Шаг 3**  
- Словарь: `{0: X, 1: A, 2: Б}`  
- Текст: `"АКАН"`  
- Макс. часть `Y` — `A` (есть в словаре под индексом `1`), след. символ `К`.  
- Добавляем `3: AK` (код `⟨1, К⟩`).  
- Новый текст: `"АН"`.  

#### **Шаг 4**  
- Словарь: `{0: X, 1: A, 2: Б, 3: AK}`  
- Текст: `"АН"`  
- Макс. часть `Y` — `A`, след. символ `Н`.  
- Добавляем `4: AH` (код `⟨1, H⟩`).  
- Текст пуст — конец.  

###  **Итог**  
- **Словарь** вырос динамически:  
  ```
  0: X  
  1: A  
  2: Б  
  3: AK  
  4: AH  
  ```  
- **Сжатый код**: последовательность пар `⟨индекс, буква⟩`:  
  `⟨0,A⟩, ⟨0,Б⟩, ⟨1,К⟩, ⟨1,H⟩`. 

---

## Проверь себя

#### 1. Что такое кодирование с целью сжатия?
``` quiz
- Процесс увеличения размера данных для улучшения качества
+ Преобразование данных для уменьшения занимаемого места в памяти
- Шифрование данных с использованием сложных алгоритмов
- Удаление всех повторяющихся символов из данных
```
---

#### 2. Какой алгоритм сжатия основан на поиске повторяющихся последовательностей?
``` quiz
- Алгоритм Хаффмана
+ Алгоритм Лемпеля-Зива
- Алгоритм RSA
- Алгоритм DES.
```
---

#### 3. Какие виды сжатия данных существуют?
``` quiz
+ Без потерь и с потерями
- Линейное и нелинейное
- Дискретное и аналоговое
- Статическое и динамическое
``` 
---

#### 4. Как формируется код в алгоритме Лэмпела - Зива?
``` quiz
- В виде одиночных символов
+ В виде пар ⟨индекс_словаря, новый_символ⟩
- В виде троек ⟨смещение, длина, символ⟩
- В виде хеш-значений
``` 
---

#### 5. Что происходит, если в словаре  уже есть фраза "AK", а следующая фраза — "AKA"?
``` quiz
- "AKA" заменяется на ⟨0, A⟩
+  "AKA" добавляется в словарь, а код будет ⟨индекс_AK, A⟩
- Алгоритм перестаёт работать
- "AKA" игнорируется
``` 
---

#### 6. Какой пример демонстрирует работу алгоритма?
``` quiz
- "AAAA" → "4A"
+ "ABACABA" → ⟨0,A⟩, ⟨0,B⟩, ⟨1,C⟩, ⟨3,A⟩
- "Hello" → "H-e-l-l-o"
-  "12345" → "1 2 3 4 5"
``` 
--- 

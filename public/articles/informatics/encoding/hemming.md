<!-- [difficulty=hard] [priority=extra] [duration=long] -->

# Код Хемминга

> Код Хемминга — это способ **обнаруживать и исправлять ошибки** при передаче данных (например, 1 бит изменился на 0 из-за помех).

---
## Как работает?

### Добавляем контрольные биты
Допустим, есть данные: `1101`.  
Добавляем контрольные биты на позиции **1, 2, 4** (степени двойки):  
`_ _ 1 _ 1 0 1` → заполняем `_` нулями: `0 0 1 0 1 0 1`

### Вычисляем контрольные биты
Каждый контрольный бит проверяет определённые биты данных:
**Бит 1**: 
биты 1, 3, 5, 7 (нечётные) 
Пример: $0$ (бит1) $⊕ 1$ (бит3) $⊕ 1$ (бит5) $⊕ 1$ (бит7) $= 1 → ставим 1$
**Бит 2**: 
биты 2, 3, 6, 7  
$0 ⊕ 1 ⊕ 0 ⊕ 1 = 0 →$ оставляем $0$
**Бит 4**: 
биты 4, 5, 6, 7  
$0 ⊕ 1 ⊕ 0 ⊕ 1 = 0 →$ оставляем $0$

Итоговое закодированное сообщение: `1 0 1 0 1 0 1`

### Обнаружение ошибки
Допустим, при передаче исказился **бит 5** (`1` → `0`):  
`1 0 1 0 0 0 1`

Вычисляем результат проверки (проверяем контрольные биты заново):
- Бит 1: $1 ⊕ 1 ⊕ 0 ⊕ 1 = 1$ (ожидали $1 →$ ошибки нет)  
- Бит 2: $0 ⊕ 1 ⊕ 0 ⊕ 1 = 0$ (ожидали $0 →$ ошибки нет)  
- Бит 4: $0 ⊕ 0 ⊕ 0 ⊕ 1 = 1$ (ожидали $0 →$ **ошибка!**)  

Сумма неверных битов: `4` (только бит 4 дал ошибку) → **ошибка в бите 5** (4+1).

---

## Формула для расчёта контрольных битов
Количество контрольных битов `k` выбирается так:

$2^k ≥ k + m + 1$, где `m` — число бит данных.

---

Пусть нам нужно передать 8-битное число: `11010011`

### Определяем количество контрольных битов
Используем формулу: $2^k ≥ k + 8 + 1`$ 

Подходит $k=4 (16 ≥ 13)$  

Общая длина сообщения: $8 + 4 = 12$ бит

### Размещаем биты
Контрольные биты на позициях 1,2,4,8:  

| Позиция | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
|---------|---|---|---|---|---|---|---|---|---|----|----|----|
| Тип | C | C | D | C | D | D | D | C | D | D | D | D |
| Временное значение | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1 |

### Вычисляем контрольные биты
1. **Бит 1** (проверяет 1,3,5,7,9,11):
   $0⊕1⊕1⊕0⊕1⊕0 = 1$
2. **Бит 2** (проверяет 2,3,6,7,10,11):
   $0⊕1⊕0⊕0⊕1⊕0 = 0$
3. **Бит 4** (проверяет 4,5,6,7,12):
   $0⊕1⊕0⊕0⊕1 = 0$
4. **Бит 8** (проверяет 8,9,10,11,12):
   $0⊕1⊕1⊕0⊕1 = 1$

Итоговое сообщение: `1 0 1 0 1 0 0 1 1 1 0 1`

### Шаг 4: Обнаружение двойной ошибки
Допустим, при передаче исказились биты 5 и 9:
Получаем: `1 0 1 0 0 0 0 1 0 1 0 1`

Вычисляем результат проверки:
1. Бит1: $1⊕1⊕0⊕0⊕0⊕0 = 0$ (должно быть 1) $→ +1$
2. Бит2: $0⊕1⊕0⊕0⊕1⊕0 = 0$ (должно быть 0) $→ +0$
3. Бит4: $0⊕0⊕0⊕0⊕1 = 1$ (должно быть 0) $→ +4$
4. Бит8: $1⊕0⊕1⊕0⊕1 = 1$ (должно быть 1) $→ +0$

Сумма: $1 + 4 = 5 →$ ошибка в бите 5. Но мы знаем, что ошибок может быть несколько!

### Важное ограничение:
Код Хемминга **может исправить только 1 ошибку** и обнаружить 2 ошибки. В этом случае:
- Результат проверки ненулевой (значит, есть ошибки)
- Невозможно однозначно определить две ошибки
- Нужна повторная передача данных
---
## Проверь себя

### Закодируйте данные `1011` с исправлением ошибки в 3-м бите (индексация с 1).

```test
"answer": "0110011",
"validator": "/^[01]+$/"
```
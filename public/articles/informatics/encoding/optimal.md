# Оптимальное кодирование

> Метод кодирования информации, при котором достигается минимальная избыточность данных, то есть сообщение передаётся или хранится с наименьшим возможным количеством битов (или других символов).

### Основные принципы оптимального кодирования:

1. **Минимизация средней длины кода** – часто встречающиеся символы кодируются более короткими кодами, а редкие – более длинными.
2. **Отсутствие префиксов** – ни один код не должен быть началом другого (это гарантирует однозначность декодирования).
3. **Эффективность** – код должен быть максимально компактным для данного распределения вероятностей символов.

### Примеры алгоритмов оптимального кодирования:

- **Код Хаффмана**
- **Арифметическое кодирование**
- **Код Шеннона-Фано**

---
## **Код Хаффмана**

Используется для сжатия данных путём замены часто встречающихся символов более короткими кодами, а редких - более длинными.

### Код Хаффмана для n = 2 (двоичное кодирование)

Это классический алгоритм построения оптимального префиксного кода, где на каждом шаге объединяются **два** символа с наименьшими вероятностями.

### **Пошаговое объяснение алгоритма**

### Условия и обозначения
- **Вход**: Множество символов $S= \{s_1,s_2,...,s_n\}$ с вероятностями $P=\{p_1,p_2,...,p_n\}$, где $p_i$ - вероятность символа $s_i$.
- **Выход**: Двоичные коды ω1,ω2,…,ωn для каждого символа.
- **n = 2**: На каждом шаге объединяются **два** символа (бинарное дерево).

### Алгоритм

#### Шаг 1. Сортировка по убыванию вероятностей

Символы упорядочиваются так, чтобы $p_1 \ge p_2 \ge ... \ge p_n$.

#### Шаг 2. Построение дерева Хаффмана

Пока есть больше одного символа:

1. **Выбрать два символа с наименьшими вероятностями**siиsj.
    
2. **Объединить их в новый составной символ**snew с вероятностьюpnew=pi+pj.
    
3. **Пометить ребра**:
    
    - Левое ребро →`0`(например, дляsi).
        
    - Правое ребро →`1`(например, дляsj).
    
4. **Заменитьsiиsjнаsnewsnew**.
    
5. **Повторять**, пока не останется один корневой узел (с вероятностью 1).

#### Шаг 3. Построение кодов

- Каждому символу соответствует**путь от корня до листа**в дереве.
    
- Код символа — последовательность`0`и`1`на этом пути.

### **Пример**

**Дано:**

|Символ|Вероятность|
|---|---|
|A|0.4|
|B|0.3|
|C|0.2|
|D|0.1|

#### Шаг 1. Сортировка

Уже отсортировано: $A(0.4) \ge B(0.3) \ge C(0.2) \ge D(0.1)$.

#### Шаг 2. Построение дерева

1. **Объединяем C и D** (наименьшие вероятности):
    
    - Новый узел: $(C+D)сp=0.2+0.1=0.3$
    - Ребра: `C → 0`,`D → 1`
    - Теперь символы: $A(0.4),B(0.3),(C+D)(0.3)$
        
2. **Объединяем B и (C+D)**(оба сp=0.3):
    
    - Новый узел: $(B+C+D)сp=0.3+0.3=0.6$
    - Ребра:`B → 0`,`(C+D) → 1`.
    - Теперь символы: $A(0.4),(B+C+D)(0.6)$
        
3. **Объединяем A и (B + C + D)**:
    
    - Корень: $(A+B+C+D) сp=0.4+0.6=1.0$
    - Ребра:`A → 0`,`(B + C + D) → 1`.
        

#### Шаг 3. Получение кодов

- **A**:`0` (путь: корень → A).
- **B**:`10` (корень → (B+C+D) → B).
- **C**:`110` (корень → (B+C+D) → (C+D) → C).
- **D**:`111` (корень → (B+C+D) → (C+D) → D).
    

**Итоговые коды:**

|Символ|Код|
|---|---|
|A|0|
|B|10|
|C|110|
|D|111|

---

## **Код Фано**
метод построения префиксного кода, альтернативный алгоритму Хаффмана. Он также обеспечивает эффективное сжатие данных, но работает по другому принципу:**рекурсивное разбиение множества символов на две части с примерно равными суммарными вероятностями**.

## **1. Пошаговое объяснение алгоритма**

### Входные данные:

- Множество символов $S=\{s_1,s_2,…,s_n\}$.
    
- Вероятности символов $P=\{p_1,p_2,…,p_n\}$, гдеpi — вероятностьsi.
### Выходные данные:

- Двоичные коды $ω_1,ω_2,...,ω_n,ω_1,ω_2,...,ω_n$ для каждого символа.
    
### Шаги алгоритма:

1. **Сортировка символов по убыванию вероятностей**  
    $p_1 \ge p_2 \ge ... \ge p_n$.
    
2. **Разбиение на две части**  
    Найти индекс $k$, такой что сумма вероятностей левой частимаксимально близка к сумме правой части.
    - Левой части присваивается бит`0`.
    - Правой части присваивается бит`1`.
    
3. **Рекурсивное применение**  
    Каждая часть (если содержит >1 символ) разбивается аналогично, добавляя новые биты к кодам.
    
4. **Формирование кодов**  
    Код символа — последовательность битов, полученных на пути от корня до символа.

## **Пример построения кода Фано**

**Дано:**

|Символ|Вероятность|
|---|---|
|A|0.35|
|B|0.25|
|C|0.20|
|D|0.10|
|E|0.10|

### Шаг 1. Сортировка

Уже отсортировано: $A(0.35) \ge B(0.25) \ge C(0.20) \ge D(0.10) \ge E(0.10)$.

### Шаг 2. Первое разбиение

Найдемk, при котором суммы вероятностей в частях максимально близки:

- k=1:{A}(0.35)и{B,C,D,E}(0.65)→ разница $∣ 0.35 − 0.65 ∣ = 0.30$.
- k=2:{A,B}(0.60)и{C,D,E}(0.40)→ разница $∣ 0.60 − 0.40 ∣ = 0.20$.
- k=3:{A,B,C}(0.80)и{D,E}(0.20)→ разница $∣ 0.80 − 0.20 ∣ = 0.60$.
 
**Выбираем k=2**(минимальная разница):

- Левая часть (A,B) → `0`.
- Правая часть (C,D,E) → `1`.
    

### Шаг 3. Рекурсивное разбиение левой части (A,B)
- {A}(0.35)и{B}(0.25).
- A → `00` (добавляем `0`).
- B → `01` (добавляем `1`).

### Шаг 4. Рекурсивное разбиение правой части (C,D,EC,D,E)
- Найдем оптимальное разбиение:
- k=1:{C}(0.20) и {D,E}(0.20) → разница 0.
- Левая часть (C) → `10`.
- Правая часть (D,E) → `11`.
- Разбиваем{D,E}:
- D → `110`.
- E → `111`.

### Итоговые коды:

|Символ|Код|
|---|---|
|A|00|
|B|01|
|C|10|
|D|110|
|E|111|

---
## **Проверь себя**

### Какой из перечисленных алгоритмов гарантированно строит оптимальный префиксный код?

```quiz
- Код Фано
+ Код Хаффмана
- Оба алгоритма одинаково оптимальны
- Ни один из них
```
### Какой принцип лежит в основе алгоритма Хаффмана?

```quiz
- Рекурсивное разбиение символов на группы с равными вероятностями
- Использование только равномерных кодов
-  Случайное назначение кодов символов
+ Объединение символов с наименьшими вероятностями на каждом шаге
```
### В алгоритме Фано на каждом шаге:

```quiz
+ Множество символов разбивается на две части с близкими суммарными вероятностями
- Символы сортируются по возрастанию вероятностей
- Объединяются три символа
- Используется только один кодовый символ
```
### Для каких данных оптимальное кодирование наиболее эффективно?

```quiz
- когда вероятности символов сильно различаются
+ Когда все символы равновероятны
- Когда количество символов не превышает 2
- Когда используется алфавит из 256 символов
```

### Какой код будет у символа «D» после применения алгоритма Хаффмана для вероятностей: A=0.5, B=0.25, C=0.125, D=0.125?

```quiz
- 00
- 01
+ 110
- 111
```
